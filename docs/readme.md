# Pedestrian routing using open map data

A-level Computer Science programming project

## Analysis

### Problem definition

A routing engine is a piece of software that calculates a route between two points in the world, following a pre-defined network of paths or roads. Routing engines first became commonly used with satnavs that provide live directions for driving. Nowadays, mobile apps perform the same task, and can be used for driving as well as walking or cycling.

Modern routing engines use geographic data of roads to 
<!-- TODO -->

### Justification of computational approach

The task of finding an efficient route between two geographic locations has some complexities, such as the need for an algorithm to chose which paths to explore without knowing for sure which ones will be optimal. However, these challenges have successfully been overcome by a variety of programs that incorporate routing engines. This task is solvable with an algorithm because it of four characteristics: an initial situation, clear inputs and outputs, clearly defined logic, and a clear goal. These will be discussed in detail below.

#### Initial situation

The routing engine is provided with coordinates for a starting point, and coordinates for the ending point. The initial situation for the program will be a graph that represents a network of paths for the area that will be covered by the routing query. The graph will be generated by processing map data from OpenStreetMap with the following steps:

1. Extract ways that represent a walkable section of a route, e.g. paths, roads, plazas. This will be done by checking for corresponding top-level tags, e.g. `highway=footway`.
2. Also extract the nodes from each way. Untagged nodes that aren't intersections can be ignored.
3. Use a recursive algorithm to walk through the extracted map data, building a graph where intersections and barriers are represented as graph nodes, and segments of walkable ways are represented as edges. A weight for each node and edge will be calculated to represent how desirable it would be to navigate that node, or walk along that edge.

#### Clear goal

Its goal is to provide the user with a real-world path that they can follow on foot to navigate from the start to the end point, as well as a series of steps that describe the route in text. The route should follow walkable map objects to ensure it makes sense as a route. The engine should generate routes that are desirable to a user looking to travel safely and efficiently (i.e. minimising the effort required to follow the route).<!-- Planing walks for leisure (e.g. circular path walks through woods) --> To achieve this, the engine will follow the following principles:

* Prefer a shorter-distance route, all else being equal
* Prefer pavements over roads without pavements
* Prefer paved paths over unpaved ones
* Prefer signalled crossings to unsignalled ones, especially if crossing a busy road
* Prefer well-marked paths to difficult-to-spot ones
* Avoid obstructions that may pose an issue for pedestrians (e.g. fallen trees)

In addition to the points above, the most desirable route for a user will depend on their own preferences and physical abilities. To accommodate this, the engine will be configurable to prioritise routes that are suitable for the specific user. Goals that should be configurable are:

* Avoid high kerbs, and prefer crossings with flush kerbs
* Prefer crossings with tactile paving
* Prefer paths that are lit at night
* Avoid steps
* Avoid large numbers of steps
* Prefer steps where a handrail is available
* Prefer paths wide enough for a wheelchair
* Prefer crossings with audible indicators
* Prefer crossings with tactile indicators

#### Clear inputs and outputs

Its outputs would be a list of directions that the user can follow to navigate from the start to the end.

#### Clearly defined logic

It will use this graph to find the optimal route between the two points using a pathfinding algorithm such as A*.
